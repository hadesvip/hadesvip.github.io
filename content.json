{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://hadesvip.github.io"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2018-01-19T02:46:14.348Z","updated":"2018-01-19T02:46:14.348Z","comments":false,"path":"/404.html","permalink":"http://hadesvip.github.io//404.html","excerpt":"","text":""},{"title":"关于","date":"2018-01-19T02:46:14.352Z","updated":"2018-01-19T02:46:14.352Z","comments":false,"path":"about/index.html","permalink":"http://hadesvip.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2018-01-19T02:46:14.352Z","updated":"2018-01-19T02:46:14.352Z","comments":false,"path":"books/index.html","permalink":"http://hadesvip.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-01-19T02:46:14.352Z","updated":"2018-01-19T02:46:14.352Z","comments":false,"path":"categories/index.html","permalink":"http://hadesvip.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-01-19T02:46:14.352Z","updated":"2018-01-19T02:46:14.352Z","comments":false,"path":"repository/index.html","permalink":"http://hadesvip.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-01-19T02:02:50.990Z","updated":"2018-01-19T02:02:50.990Z","comments":true,"path":"links/index.html","permalink":"http://hadesvip.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-01-19T02:46:14.352Z","updated":"2018-01-19T02:46:14.352Z","comments":false,"path":"tags/index.html","permalink":"http://hadesvip.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SPI(service provider interface)详解","slug":"SPI-service-provider-interface-详解","date":"2018-01-23T01:56:15.000Z","updated":"2018-01-23T03:55:54.728Z","comments":true,"path":"2018/01/23/SPI-service-provider-interface-详解/","link":"","permalink":"http://hadesvip.github.io/2018/01/23/SPI-service-provider-interface-详解/","excerpt":"","text":"概述SPI全称为service provider interface ,是JDK自带的一种服务提供发现机制，类似于一种小型的IOC容器，可以自动依赖注入,动态替换服务扩展.一般用于提供第三方实现和扩展,可以增加框架的扩展和替换一些组件.目前很多框架使用了这个机制，比如spring,dubbo,还是数据库驱动包，设置JDK里面的NIO包中的SelectorProvider也是使用的这个机制. SPI约定 在META-INF/services/目录中创建接口的权限名命名的文件,该文件内容为接口实现的全限名,文件编码为UTF-8 使用SeriveLoader.load(Class class) 动态加载接口的实现 实现类必须有一个无参构造 如果SPI的实现是一个jar,放在项目的classpath目录下 springmvc对servlet3.0的支持在servlet3.0情况下,可以不使用web.xml文件,可以使用WebApplicationInitializer来初始化一个WebApplicationContext. WebApplicationInitializer加载机制:javaEE容器启动的时候会通过SPI机制寻找javax.servlet.ServletContainerInitializer的实现类,在spring-web包下面,有这个文件的定义. 12345678910111213141516171819202122232425262728293031323334353637@HandlesTypes(WebApplicationInitializer.class)public class SpringServletContainerInitializer implements ServletContainerInitializer &#123; @Override public void onStartup(Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext) throws ServletException &#123; List&lt;WebApplicationInitializer&gt; initializers = new LinkedList&lt;WebApplicationInitializer&gt;(); if (webAppInitializerClasses != null) &#123; for (Class&lt;?&gt; waiClass : webAppInitializerClasses) &#123; // Be defensive: Some servlet containers provide us with invalid classes, // no matter what @HandlesTypes says... if (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp; WebApplicationInitializer.class.isAssignableFrom(waiClass)) &#123; try &#123; initializers.add((WebApplicationInitializer) waiClass.newInstance()); &#125; catch (Throwable ex) &#123; throw new ServletException(&quot;Failed to instantiate WebApplicationInitializer class&quot;, ex); &#125; &#125; &#125; &#125; if (initializers.isEmpty()) &#123; servletContext.log(&quot;No Spring WebApplicationInitializer types detected on classpath&quot;); return; &#125; AnnotationAwareOrderComparator.sort(initializers); servletContext.log(&quot;Spring WebApplicationInitializers detected on classpath: &quot; + initializers); for (WebApplicationInitializer initializer : initializers) &#123; initializer.onStartup(servletContext); &#125; &#125;&#125; 在onStartup方法上面有一段这样的注释: Because this class declares @{@code &gt;HandlesTypes(WebApplicationInitializer.class)},Servlet 3.0+ containers will automatically scan the classpath for implementations of Spring’s {@code WebApplicationInitializer} interface and provide the set of allsuch types to the {@code webAppInitializerClasses} parameter of this &gt;method. 因为这个类的注解是HandlesTypes(WebApplicationInitializer.class),servlet3.0容器会自动扫描classpath下面对WebApplicationInitializer接口的实现类,并以set类型的参数提供给SpringServletContainerInitializer.onStartup()方法 自己使用SPI特性实现一个service新建一个spi-demo的工程,项目结构如下图: 定义service接口 123456package com.spi.demo.service;public interface UserService &#123; String sayHello(String userName);&#125; 提供provider实现 1234567891011package com.spi.demo.service.impl;import com.spi.demo.service.UserService;public class UserServiceImpl implements UserService &#123; @Override public String sayHello(String userName) &#123; return new StringBuffer(&quot;hello,&quot;).append(userName).append(&quot;.&quot;).toString(); &#125;&#125; 添加配置resouces/META-INF/services/目录下新建com.spi.demo.service.UserService文件,编码为UTF-8 文件内容如下: 1com.spi.demo.service.impl.UserServiceImpl 运行测试 1234567891011121314package com.spi.demo;import com.spi.demo.service.UserService;import java.util.ServiceLoader;public class Console &#123; public static void main(String[] args) &#123; ServiceLoader&lt;UserService&gt; serviceLoader = ServiceLoader.load(UserService.class); serviceLoader.iterator() .forEachRemaining(userService -&gt; System.out.println(userService.sayHello(&quot;张三&quot;))); &#125;&#125; 运行输出结果如下 1hello,张三. 参考资料 https://en.wikipedia.org/wiki/Service_provider_interface","categories":[{"name":"java","slug":"java","permalink":"http://hadesvip.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://hadesvip.github.io/tags/java/"},{"name":"dubbo源码","slug":"dubbo源码","permalink":"http://hadesvip.github.io/tags/dubbo源码/"}]},{"title":"高性能IO模型","slug":"高性能IO模型","date":"2018-01-20T12:41:42.000Z","updated":"2018-01-20T14:10:02.970Z","comments":true,"path":"2018/01/20/高性能IO模型/","link":"","permalink":"http://hadesvip.github.io/2018/01/20/高性能IO模型/","excerpt":"","text":"常见的IO模型 同步阻塞IO(Blocking IO) :传统的IO类型 同步非阻塞IO(Non-blocking IO):默认创建的scoket都是堵塞的，非堵塞IO要求socket被设置为NONBLOCK. IO多路服用(IO Multiplexing):经典的Reactor设计模式,异步阻塞IO,java中的Selector和Linux的epoll都是这种模型． 异步IO(AIO): 经典的Proactor设计模式，也称为异步非堵塞IO. 同步和异步同步和异步的概念描述的是用户线程与内核的交互方式:同步是指用户线程发起IO请求后需要等待或者轮询内核IO操作完成后才能继续执行；而异步是指用户线程发起IO请求后仍继续执行,当内核IO操作完成后会通知用户线程，或者调用用户线程注册的回调函数． 堵塞和非堵塞堵塞和非堵塞的概念描述的是用户线程调用内核IO操作方式:堵塞是指IO操作需要彻底完成后才返回到用户空间;而非堵塞是指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成． 同步堵塞IO同步堵塞IＯ模型是最简单的IO模型，用户线程在内核进行IO操作时候是堵塞的． 如上图所示，用户线程通过系统调用read发起IO读操作，由用户空间转到内核空间.内核等到数据包到达后，然后将接收的数据拷贝到用户空间，完成read操作． 这个过程伪代码描述 1234&#123; read(scoket,buffer) process(buffer)&#125; 用户需要等待read将socket中的数据读取到buffer后，才继续处理接收的数据，整个IO请求的过程中，用户线程是被堵塞的，这导致用户在发起IO请求时，不能做任何操作，对CPU的资源利用率不够． 同步非堵塞IOIO多路复用异步IO","categories":[{"name":"java","slug":"java","permalink":"http://hadesvip.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://hadesvip.github.io/tags/java/"}]},{"title":"dubbo源码解析(一):构建dubbo源码","slug":"dubbo源码解析-构建dubbo源码","date":"2018-01-20T07:16:56.000Z","updated":"2018-01-20T12:31:01.121Z","comments":true,"path":"2018/01/20/dubbo源码解析-构建dubbo源码/","link":"","permalink":"http://hadesvip.github.io/2018/01/20/dubbo源码解析-构建dubbo源码/","excerpt":"","text":"学习dubbo源码好处 提高soa微服务架构理解 SOA服务治理是dubbo首先提出来的，学习架构原理更能深度的理解SOA思想 提高Java底层理解还有设计模式 tcp的单工，半双工，全双工，编码，解码，拆包，粘包，netty网络框架通信，nio,线程池，boss线程，work线程，集群负载均衡loadbalace,cluster,router,zk 下载dubbo最新源码(2.6.0) dubbo项目托管在github 上面 123git clone git clone https://github.com/alibaba/dubbogit checkout -b dubbo-2.6.0 dubbo-2.6.0 构建环境 maven3.5.0 java8 idea 直接导入idea中 命令行构建 12cd dubbomvn clean package -DskipTests dubbo源码包介绍 dubbo-admin dubbo控制台管理项目 dubbo-cluster dubbo集群实现 dubbo-common dubbo公共类或者工具 dubbo-config dubbo配置实现 dubbo-container dubbo容器:spring容器,jetty,日记实现 dubbo-demo 官网提供的demo dubbo-filter dubbo缓存和验证 dubbo-registry dubbo核心注册中心实现,zk,redis,广播，直连 dubbo-monitor 监控模块，统计服务调用次数和时间，调用链跟踪服务 dubbo-remoting dubbo远程通讯实现 dubbo-rpc 远程调用模块 dubbo-test dubbo一些测试","categories":[{"name":"java","slug":"java","permalink":"http://hadesvip.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://hadesvip.github.io/tags/java/"},{"name":"dubbo源码","slug":"dubbo源码","permalink":"http://hadesvip.github.io/tags/dubbo源码/"}]},{"title":"dubbo教程(一):dubbo入门Demo","slug":"dubbo教程-一-dubbo入门Demo","date":"2018-01-19T06:30:26.000Z","updated":"2018-01-20T08:24:02.377Z","comments":true,"path":"2018/01/19/dubbo教程-一-dubbo入门Demo/","link":"","permalink":"http://hadesvip.github.io/2018/01/19/dubbo教程-一-dubbo入门Demo/","excerpt":"","text":"什么是dubbo? 官网: dubbo.io 官方文档－用户手册: http://dubbo.io/books/dubbo-user-book/ 高性能和透明化的RPC远程服务调用方案 SOA 服务治理方案 dubbo能做什么? 远程化的远程方法调用d 就像调用本地方法一样调用远程方法（动态代理） 只需要简单的配置，没有任何API侵入 软负载均衡及容错机制 可在内网代替F5等硬件负载均衡器 服务自动注册与发现 不需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或者删除服务提供者 dubbo原理 示例 项目demo已经存放在github上面 1git clone https://github.com/hadesvip/dubbo-demo.git 依赖 gradle java8 项目描述 dubbo-demo 父模块，主要维护了子模块的构建信息，构件信息 dubbo-demo-domain dubbo-demo的子模块，里面定义了数据类和接口 dubbo-demo-provider dubbo-demo的子模块，dubbo的服务提供者 dubbo-demo-consumer dubbo-demo的子模块,dubbo服务消费者 项目运行 预先安装zookeeper,并启动zk,启动一个zk就行了，生产环境上最好搭建一个zk集群（3的倍数） 构建 12cd dubbo-demogradle clean build 运行dubbo-demo-provider项目com.provider.Console方法 从控制台上面打印的日记可以看出连接到了zk上面，并把dubbo服务注册到了zk上 123456789101112131415//连接本地zk org.apache.zookeeper.ClientCnxn - Socket connection established to localh ost/127.0.0.1:2181, initiating session//ｚｋ状态为连接状态 org.apache.zookeeper.ClientCnxn - Session establishment complete on server localhost/127.0.0.1:2181, sessionid = 0x100003c49000000, negotiated timeout = 30000 org.I0Itec.zkclient.ZkClient - zookeeper state changed (SyncConnected) //在zk上面注册服务 [DUBBO] Register: dubbo://172.17.0.1:20880/com.service.UserService?anyhost=true&amp;application=dubbo-demo-provider-app&amp;dubbo=2.6.0&amp;generic=false&amp;interface=com.service.UserService&amp;logger=log4j&amp;methods=getUserById&amp;pid=14225&amp;side=provider&amp;timestamp=1516428681983, dubbo version: 2.6.0, current host: 172.17.0.1 //订阅configurators配置 [DUBBO] Subscribe: provider://172.17.0.1:20880/com.service.UserService?anyhost=true&amp;application=dubbo-demo-provider-app&amp;category=configurators&amp;check=false&amp;dubbo=2.6.0&amp;generic=false&amp;interface=com.service.UserService&amp;logger=log4j&amp;methods=getUserById&amp;pid=14225&amp;side=provider&amp;timestamp=1516428681983, dubbo version: 2.6.0, current host: 172.17.0.1//通知订阅这些服务的提供者 [DUBBO] Notify urls for subscribe url provider://172.17.0.1:20880/com.service.UserService?anyhost=true&amp;application=dubbo-demo-provider-app&amp;category=configurators&amp;check=false&amp;dubbo=2.6.0&amp;generic=false&amp;interface=com.service.UserService&amp;logger=log4j&amp;methods=getUserById&amp;pid=14225&amp;side=provider&amp;timestamp=1516428681983, urls: [empty://172.17.0.1:20880/com.service.UserService?anyhost=true&amp;application=dubbo-demo-provider-app&amp;category=configurators&amp;check=false&amp;dubbo=2.6.0&amp;generic=false&amp;interface=com.service.UserService&amp;logger=log4j&amp;methods=getUserById&amp;pid=14225&amp;side=provider&amp;timestamp=1516428681983], dubbo version: 2.6.0, current host: 172.17.0.1 运行dubbo-demo-consumer项目 com.consumer.Console 控制台输出下面语句，说明服务调用成功 1User&#123;userId=&apos;001&apos;, userName=&apos;admin&apos;, email=&apos;admin@126.com&apos;&#125; 从控制台日记也可以知道一些细节 12345678910111213141516171819//连接zkINFO org.apache.zookeeper.ClientCnxn - Socket connection established to localhost/127.0.0.1:2181, initiating session//ZK状态改变为连接状态INFO org.I0Itec.zkclient.ZkClient - zookeeper state changed (SyncConnected)//注册消费者[DUBBO] Register: consumer://172.17.0.1/com.service.UserService?application=dubbo-demo-consumer-app&amp;category=consumers&amp;check=false&amp;dubbo=2.6.0&amp;interface=com.service.UserService&amp;logger=log4j&amp;methods=getUserById&amp;pid=15803&amp;side=consumer&amp;timestamp=1516429428346, dubbo version: 2.6.0, current host: 172.17.0.1//订阅providers,configurators,routers[DUBBO] Subscribe: consumer://172.17.0.1/com.service.UserService?application=dubbo-demo-consumer-app&amp;category=providers,configurators,routers&amp;dubbo=2.6.0&amp;interface=com.service.UserService&amp;logger=log4j&amp;methods=getUserById&amp;pid=15803&amp;side=consumer&amp;timestamp=1516429428346, dubbo version: 2.6.0, current host: 172.17.0.1// 通知订阅了这个地址的服务消费者[DUBBO] Notify urls for subscribe url consumer://172.17.0.1/com.service.UserService?application=dubbo-demo-consumer-app&amp;category=providers,configurators,routers&amp;dubbo=2.6.0&amp;interface=com.service.UserService&amp;logger=log4j&amp;methods=getUserById&amp;pid=15803&amp;side=consumer&amp;timestamp=1516429428346, urls: [dubbo://172.17.0.1:20880/com.service.UserService?anyhost=true&amp;application=dubbo-demo-provider-app&amp;dubbo=2.6.0&amp;generic=false&amp;interface=com.service.UserService&amp;logger=log4j&amp;methods=getUserById&amp;pid=14225&amp;side=provider&amp;timestamp=1516428681983, empty://172.17.0.1/com.service.UserService?application=dubbo-demo-consumer-app&amp;category=configurators&amp;dubbo=2.6.0&amp;interface=com.service.UserService&amp;logger=log4j&amp;methods=getUserById&amp;pid=15803&amp;side=consumer&amp;timestamp=1516429428346, empty://172.17.0.1/com.service.UserService?application=dubbo-demo-consumer-app&amp;category=routers&amp;dubbo=2.6.0&amp;interface=com.service.UserService&amp;logger=log4j&amp;methods=getUserById&amp;pid=15803&amp;side=consumer&amp;timestamp=1516429428346], dubbo version: 2.6.0, current host: 172.17.0.1//成功连接到这个服务地址Successed connect to server /172.17.0.1:20880 from NettyClient 172.17.0.1 using dubbo version 2.6.0, channel is NettyChannel [channel=[id: 0x7f2cfe3f, /172.17.0.1:49624 =&gt; /172.17.0.1:20880]], dubbo version: 2.6.0, current host: 172.17.0.1Refer dubbo service com.service.UserService from url zookeeper://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?anyhost=true&amp;application=dubbo-demo-consumer-app&amp;check=false&amp;dubbo=2.6.0&amp;generic=false&amp;interface=com.service.UserService&amp;logger=log4j&amp;methods=getUserById&amp;pid=15803&amp;register.ip=172.17.0.1&amp;remote.timestamp=1516428681983&amp;side=consumer&amp;timestamp=1516429428346, dubbo version: 2.6.0, current host: 172.17.0.1 在dubbo-demo-provider 控制台也会有下面日记输出 1234567891011//消费者请求4:22:45.913 [New I/O server worker #1-1] WARN c.a.d.r.transport.AbstractServer - [DUBBO] All clients has discontected from /172.17.0.1:20880. You can graceful shutdown now., dubbo version: 2.6.0, current host: 172.17.0.114:22:45.913 [DubboServerHandler-172.17.0.1:20880-thread-3] INFO c.a.d.r.protocol.dubbo.DubboProtocol - [DUBBO] disconected from /192.168.31.44:49580,url:dubbo://172.17.0.1:20880/com.service.UserService?anyhost=true&amp;application=dubbo-demo-provider-app&amp;bind.ip=172.17.0.1&amp;bind.port=20880&amp;channel.readonly.sent=true&amp;codec=dubbo&amp;dubbo=2.6.0&amp;generic=false&amp;heartbeat=60000&amp;interface=com.service.UserService&amp;logger=log4j&amp;methods=getUserById&amp;pid=14225&amp;side=provider&amp;timestamp=1516428681983, dubbo version: 2.6.0, current host: 172.17.0.114:23:49.175 [New I/O server worker #1-2] WARN c.a.d.r.transport.AbstractServer - [DUBBO] All clients has discontected from /172.17.0.1:20880. You can graceful shutdown now., dubbo version: 2.6.0, current host: 172.17.0.114:23:49.175 [DubboServerHandler-172.17.0.1:20880-thread-6] INFO c.a.d.r.protocol.dubbo.DubboProtocol - [DUBBO] disconected from/192.168.31.44:49624,url:dubbo://172.17.0.1:20880/com.service.UserService?anyhost=true&amp;application=dubbo-demo-provider-app&amp;bind.ip=172.17.0.1&amp;bind.port=20880&amp;channel.readonly.sent=true&amp;codec=dubbo&amp;dubbo=2.6.0&amp;generic=false&amp;heartbeat=60000&amp;interface=com.service.UserService&amp;logger=log4j&amp;methods=getUserById&amp;pid=14225&amp;side=provider&amp;timestamp=1516428681983, dubbo version: 2.6.0, current host: 172.17.0.1 更多资料 https://dubbo.io","categories":[{"name":"java","slug":"java","permalink":"http://hadesvip.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://hadesvip.github.io/tags/java/"},{"name":"dubbo","slug":"dubbo","permalink":"http://hadesvip.github.io/tags/dubbo/"},{"name":"rpc","slug":"rpc","permalink":"http://hadesvip.github.io/tags/rpc/"},{"name":"soa","slug":"soa","permalink":"http://hadesvip.github.io/tags/soa/"}]},{"title":"codeStyle模板和p3c代码规则检测插件配置","slug":"codeStyle模板和p3c代码规则检测插件配置","date":"2018-01-19T03:25:39.000Z","updated":"2018-01-19T07:13:16.915Z","comments":true,"path":"2018/01/19/codeStyle模板和p3c代码规则检测插件配置/","link":"","permalink":"http://hadesvip.github.io/2018/01/19/codeStyle模板和p3c代码规则检测插件配置/","excerpt":"","text":"格式化模板 使用的是谷歌的codeStyle 地址 1git clone https://github.com/google/styleguide.git 配置(下面是关于idea中的配置,eclipse同理) eclipse 选择的是eclipse-java-google-style.xml ,idea 选择的是 intellij-java-google-style.xml p3c代码规则检测插件 阿里的代码规则检测插件 地址 1git clone https://github.com/alibaba/p3c.git 安装 idea eclipse 参照官方描述 https://github.com/alibaba/p3c/tree/master/eclipse-plugin 使用 参照 https://github.com/alibaba/p3c/wiki","categories":[{"name":"java","slug":"java","permalink":"http://hadesvip.github.io/categories/java/"}],"tags":[{"name":"工作笔记","slug":"工作笔记","permalink":"http://hadesvip.github.io/tags/工作笔记/"},{"name":"工具","slug":"工具","permalink":"http://hadesvip.github.io/tags/工具/"},{"name":"java","slug":"java","permalink":"http://hadesvip.github.io/tags/java/"}]}]}