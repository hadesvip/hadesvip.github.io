{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://hadesvip.github.io"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2018-01-23T11:54:16.711Z","updated":"2018-01-23T11:54:16.711Z","comments":false,"path":"/404.html","permalink":"http://hadesvip.github.io//404.html","excerpt":"","text":""},{"title":"关于","date":"2018-01-23T11:54:16.711Z","updated":"2018-01-23T11:54:16.711Z","comments":false,"path":"about/index.html","permalink":"http://hadesvip.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2018-01-23T11:54:16.711Z","updated":"2018-01-23T11:54:16.711Z","comments":false,"path":"books/index.html","permalink":"http://hadesvip.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-01-23T11:54:16.711Z","updated":"2018-01-23T11:54:16.711Z","comments":false,"path":"categories/index.html","permalink":"http://hadesvip.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-01-23T11:54:16.711Z","updated":"2018-01-23T11:54:16.711Z","comments":false,"path":"repository/index.html","permalink":"http://hadesvip.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-01-23T11:54:16.707Z","updated":"2018-01-23T11:54:16.707Z","comments":true,"path":"links/index.html","permalink":"http://hadesvip.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-01-23T11:54:16.711Z","updated":"2018-01-23T11:54:16.711Z","comments":false,"path":"tags/index.html","permalink":"http://hadesvip.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2018年清单","slug":"2018年清单","date":"2018-02-23T03:48:17.000Z","updated":"2018-02-23T05:58:47.557Z","comments":true,"path":"2018/02/23/2018年清单/","link":"","permalink":"http://hadesvip.github.io/2018/02/23/2018年清单/","excerpt":"","text":"生活 作息做到规律,做到早睡早起,做到早上6点起床,晚上11点睡觉 坚持锻炼,把体重控制到150左右 周末时间多出去走走,不继续宅家里,多运动 学会做五六个小菜 工作 工作多做计划,把每天工作的内容做清单 每周对本周的工作内容进行复盘,每月对本月内容进行复盘 学习 坚持写博客,做到每周一篇博文 springcloud nio netty grpc jvm dubbo源码分析继续 并发 计划看的书籍 netty实战 Docker开发指南 Docker经典实例 Effective Java第三版 kafka kotlin实战","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"http://hadesvip.github.io/categories/杂七杂八/"}],"tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"http://hadesvip.github.io/tags/杂七杂八/"}]},{"title":"kafka教程(-):hello,world","slug":"kafka教程-hello-world","date":"2018-02-09T10:25:18.000Z","updated":"2018-02-09T11:00:33.537Z","comments":true,"path":"2018/02/09/kafka教程-hello-world/","link":"","permalink":"http://hadesvip.github.io/2018/02/09/kafka教程-hello-world/","excerpt":"","text":"下载kafka的官方网站是http://kafka.apache.org, 到官网下载最新版kafka_2.11-1.0.0.tgz,如下图 解压kafka_2.11-1.0.0.tgz,其目录结构如下123456789101112➜ kafka_2.11-1.0.0 ll# 存放的kafka的一系列脚本,用于操作kafkabin# kafka所需的配置config# kafka所需要的jar包libsLICENSENOTICE# 文档site-docs 运行第一个实例运行第一个实例: 生产者向kafka发送一条消息,消费者从kafka中接收一条消息 下载并配置zookeeper kafka依赖zk,通过zk来管理各种数据和元数据,kafka内部自带了zk,我们单独下载一个zk. zk官网网址:http://zookeeper.apache.org, 我们下载zookeeper-3.4.11版本,下面是我zoo.cfg中的配置 123456tickTime=2000initLimit=10syncLimit=5dataDir=/library/zookeeper-3.4.11/dataclientPort=2181","categories":[{"name":"java","slug":"java","permalink":"http://hadesvip.github.io/categories/java/"},{"name":"kafka","slug":"java/kafka","permalink":"http://hadesvip.github.io/categories/java/kafka/"}],"tags":[{"name":"java","slug":"java","permalink":"http://hadesvip.github.io/tags/java/"},{"name":"kafka","slug":"kafka","permalink":"http://hadesvip.github.io/tags/kafka/"}]},{"title":"dubbo源码分析(二):dubbo的SPI扩展实现","slug":"dubbo源码分析-二-dubbo的SPI扩展实现","date":"2018-01-31T08:47:46.000Z","updated":"2018-02-04T14:48:48.089Z","comments":true,"path":"2018/01/31/dubbo源码分析-二-dubbo的SPI扩展实现/","link":"","permalink":"http://hadesvip.github.io/2018/01/31/dubbo源码分析-二-dubbo的SPI扩展实现/","excerpt":"","text":"JDK中的SPI缺点 jdk中spi是一次性把扩展点的实现全部实例化,如果扩展点的实现很多加载很耗时间 异常无法准确捕捉提示,当扩展点的的某个实现依赖的第三方库不存在,会导致类加载失败,报的错误是找不到扩展点,而不是扩展点加载失败,以及真正的原因 dubbo对SPI的改进 增加了扩展点的默认实现 增加了AOP的实现 增加了缓存机制,提高了性能 配置文件内容改成为key=value形式,这样配置是为了改进上面所说的SPI的第二点缺点,为了将异常信息和配置对应起来 dubbo SPI实现 在需要扩展点接口使用@SPI注解标识,以前使用的Extension注解,不过后来因为含义广泛废弃,改用SPI dubbo使用ExtensionLoader.getExtensionLoader(Class type)获取扩展点实例,下面是具体实现 123456789101112131415161718192021222324252627282930313233public static &lt;T&gt; ExtensionLoader&lt;T&gt; getExtensionLoader(Class&lt;T&gt; type) &#123; //如果扩展点类型为空,抛出异常 if (type == null) &#123; throw new IllegalArgumentException(&quot;Extension type == null&quot;); &#125; //扩展点不是接口,抛出异常 if (!type.isInterface()) &#123; throw new IllegalArgumentException(&quot;Extension type(&quot; + type + &quot;) is not interface!&quot;); &#125; //扩展点没有使用spi注解 if (!withExtensionAnnotation(type)) &#123; throw new IllegalArgumentException(&quot;Extension type(&quot; + type + &quot;) is not extension, because WITHOUT @&quot; + SPI.class.getSimpleName() + &quot; Annotation!&quot;); &#125; //获取扩展点,EXTENSION_LOADERS 是一个map,key是扩展点接口类型,value是一个ExtensionLoader对象 ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type); if (loader == null) &#123; EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader&lt;T&gt;(type)); loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type); &#125; return loader;&#125;private ExtensionLoader(Class&lt;?&gt; type) &#123; this.type = type; //扩展点类型如果是ExtensionLoader,返回null,否则返回扩展装饰类 objectFactory = (type == ExtensionFactory.class ? null : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension()); &#125; 返回指定名字的扩展点对象 123456789101112131415161718192021222324252627public T getExtension(String name) &#123; if (name == null || name.length() == 0) &#123; throw new IllegalArgumentException(&quot;Extension name == null&quot;); &#125; if (&quot;true&quot;.equals(name)) &#123; return getDefaultExtension(); &#125; //从缓存中获取扩展点对象 Holder&lt;Object&gt; holder = cachedInstances.get(name); if (holder == null) &#123; cachedInstances.putIfAbsent(name, new Holder&lt;Object&gt;()); holder = cachedInstances.get(name); &#125; Object instance = holder.get(); if (instance == null) &#123; synchronized (holder) &#123; instance = holder.get(); if (instance == null) &#123; instance = createExtension(name); holder.set(instance); &#125; &#125; &#125; return (T) instance; &#125; cachedInstances 实现 123456789101112131415161718 private final ConcurrentMap&lt;String, Holder&lt;Object&gt;&gt; cachedInstances = new ConcurrentHashMap&lt;String, Holder&lt;Object&gt;&gt;(); public class Holder&lt;T&gt; &#123; /** * value线程可见性 */ private volatile T value; public void set(T value) &#123; this.value = value; &#125; public T get() &#123; return value; &#125;&#125; dubbo对spi具体使用 以protocol为例,缺省使用dubbo协议,dubbo支持默认spi扩展点 12345@SPI(&quot;dubbo&quot;)public interface Protocol &#123;//.....省略代码&#125; 配置文件 12//com.alibaba.dubbo.rpc.Protocol文件里面的配置dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol DubboProtocol 12345678910/**jdk内部的SPI机制需要通过循环判断才能获取到扩展点实例,而dubbo只需要通过通过key就可以获取扩展点实例*/public static DubboProtocol getDubboProtocol() &#123; if (INSTANCE == null) &#123; ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(DubboProtocol.NAME); // load &#125; return INSTANCE;&#125; dubbo 对IOC和AOP的增强","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://hadesvip.github.io/tags/java/"},{"name":"dubbo源码","slug":"dubbo源码","permalink":"http://hadesvip.github.io/tags/dubbo源码/"},{"name":"dubbo","slug":"dubbo","permalink":"http://hadesvip.github.io/tags/dubbo/"}]},{"title":"SPI(service provider interface)详解","slug":"SPI-service-provider-interface-详解","date":"2018-01-23T01:56:15.000Z","updated":"2018-01-23T11:54:16.711Z","comments":true,"path":"2018/01/23/SPI-service-provider-interface-详解/","link":"","permalink":"http://hadesvip.github.io/2018/01/23/SPI-service-provider-interface-详解/","excerpt":"","text":"概述SPI全称为service provider interface ,是JDK自带的一种服务提供发现机制，类似于一种小型的IOC容器，可以自动依赖注入,动态替换服务扩展.一般用于提供第三方实现和扩展,可以增加框架的扩展和替换一些组件.目前很多框架使用了这个机制，比如spring,dubbo,还是数据库驱动包，设置JDK里面的NIO包中的SelectorProvider也是使用的这个机制. SPI约定 在META-INF/services/目录中创建接口的权限名命名的文件,该文件内容为接口实现的全限名,文件编码为UTF-8 使用SeriveLoader.load(Class class) 动态加载接口的实现 实现类必须有一个无参构造 如果SPI的实现是一个jar,放在项目的classpath目录下 springmvc对servlet3.0的支持在servlet3.0情况下,可以不使用web.xml文件,可以使用WebApplicationInitializer来初始化一个WebApplicationContext. WebApplicationInitializer加载机制:javaEE容器启动的时候会通过SPI机制寻找javax.servlet.ServletContainerInitializer的实现类,在spring-web包下面,有这个文件的定义. 12345678910111213141516171819202122232425262728293031323334353637@HandlesTypes(WebApplicationInitializer.class)public class SpringServletContainerInitializer implements ServletContainerInitializer &#123; @Override public void onStartup(Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext) throws ServletException &#123; List&lt;WebApplicationInitializer&gt; initializers = new LinkedList&lt;WebApplicationInitializer&gt;(); if (webAppInitializerClasses != null) &#123; for (Class&lt;?&gt; waiClass : webAppInitializerClasses) &#123; // Be defensive: Some servlet containers provide us with invalid classes, // no matter what @HandlesTypes says... if (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp; WebApplicationInitializer.class.isAssignableFrom(waiClass)) &#123; try &#123; initializers.add((WebApplicationInitializer) waiClass.newInstance()); &#125; catch (Throwable ex) &#123; throw new ServletException(&quot;Failed to instantiate WebApplicationInitializer class&quot;, ex); &#125; &#125; &#125; &#125; if (initializers.isEmpty()) &#123; servletContext.log(&quot;No Spring WebApplicationInitializer types detected on classpath&quot;); return; &#125; AnnotationAwareOrderComparator.sort(initializers); servletContext.log(&quot;Spring WebApplicationInitializers detected on classpath: &quot; + initializers); for (WebApplicationInitializer initializer : initializers) &#123; initializer.onStartup(servletContext); &#125; &#125;&#125; 在onStartup方法上面有一段这样的注释: Because this class declares @{@code &gt;HandlesTypes(WebApplicationInitializer.class)},Servlet 3.0+ containers will automatically scan the classpath for implementations of Spring’s {@code WebApplicationInitializer} interface and provide the set of allsuch types to the {@code webAppInitializerClasses} parameter of this &gt;method. 因为这个类的注解是HandlesTypes(WebApplicationInitializer.class),servlet3.0容器会自动扫描classpath下面对WebApplicationInitializer接口的实现类,并以set类型的参数提供给SpringServletContainerInitializer.onStartup()方法 自己使用SPI特性实现一个service新建一个spi-demo的工程,项目结构如下图: 定义service接口 123456package com.spi.demo.service;public interface UserService &#123; String sayHello(String userName);&#125; 提供provider实现 1234567891011package com.spi.demo.service.impl;import com.spi.demo.service.UserService;public class UserServiceImpl implements UserService &#123; @Override public String sayHello(String userName) &#123; return new StringBuffer(&quot;hello,&quot;).append(userName).append(&quot;.&quot;).toString(); &#125;&#125; 添加配置resouces/META-INF/services/目录下新建com.spi.demo.service.UserService文件,编码为UTF-8 文件内容如下: 1com.spi.demo.service.impl.UserServiceImpl 运行测试 1234567891011121314package com.spi.demo;import com.spi.demo.service.UserService;import java.util.ServiceLoader;public class Console &#123; public static void main(String[] args) &#123; ServiceLoader&lt;UserService&gt; serviceLoader = ServiceLoader.load(UserService.class); serviceLoader.iterator() .forEachRemaining(userService -&gt; System.out.println(userService.sayHello(&quot;张三&quot;))); &#125;&#125; 运行输出结果如下 1hello,张三. 参考资料 https://en.wikipedia.org/wiki/Service_provider_interface https://docs.oracle.com/javase/8/docs/api/","categories":[{"name":"java","slug":"java","permalink":"http://hadesvip.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://hadesvip.github.io/tags/java/"},{"name":"dubbo源码","slug":"dubbo源码","permalink":"http://hadesvip.github.io/tags/dubbo源码/"}]},{"title":"高性能IO模型","slug":"高性能IO模型","date":"2018-01-20T12:41:42.000Z","updated":"2018-01-23T11:54:16.711Z","comments":true,"path":"2018/01/20/高性能IO模型/","link":"","permalink":"http://hadesvip.github.io/2018/01/20/高性能IO模型/","excerpt":"","text":"常见的IO模型 同步阻塞IO(Blocking IO) :传统的IO类型 同步非阻塞IO(Non-blocking IO):默认创建的scoket都是堵塞的，非堵塞IO要求socket被设置为NONBLOCK. IO多路服用(IO Multiplexing):经典的Reactor设计模式,异步阻塞IO,java中的Selector和Linux的epoll都是这种模型． 异步IO(AIO): 经典的Proactor设计模式，也称为异步非堵塞IO. 同步和异步同步和异步的概念描述的是用户线程与内核的交互方式:同步是指用户线程发起IO请求后需要等待或者轮询内核IO操作完成后才能继续执行；而异步是指用户线程发起IO请求后仍继续执行,当内核IO操作完成后会通知用户线程，或者调用用户线程注册的回调函数． 堵塞和非堵塞堵塞和非堵塞的概念描述的是用户线程调用内核IO操作方式:堵塞是指IO操作需要彻底完成后才返回到用户空间;而非堵塞是指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成． 同步堵塞IO同步堵塞IＯ模型是最简单的IO模型，用户线程在内核进行IO操作时候是堵塞的． 如上图所示，用户线程通过系统调用read发起IO读操作，由用户空间转到内核空间.内核等到数据包到达后，然后将接收的数据拷贝到用户空间，完成read操作． 这个过程伪代码描述 1234&#123; read(scoket,buffer) process(buffer)&#125; 用户需要等待read将socket中的数据读取到buffer后，才继续处理接收的数据，整个IO请求的过程中，用户线程是被堵塞的，这导致用户在发起IO请求时，不能做任何操作，对CPU的资源利用率不够． 同步非堵塞IOIO多路复用异步IO","categories":[{"name":"java","slug":"java","permalink":"http://hadesvip.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://hadesvip.github.io/tags/java/"}]},{"title":"dubbo源码解析(一):构建dubbo源码","slug":"dubbo源码解析-构建dubbo源码","date":"2018-01-20T07:16:56.000Z","updated":"2018-01-31T08:53:03.737Z","comments":true,"path":"2018/01/20/dubbo源码解析-构建dubbo源码/","link":"","permalink":"http://hadesvip.github.io/2018/01/20/dubbo源码解析-构建dubbo源码/","excerpt":"","text":"学习dubbo源码好处 提高soa微服务架构理解 RPC的SOA服务治理是dubbo首先提出来的(国内)，学习架构原理更能深度的理解SOA思想 提高Java底层理解还有设计模式 tcp的单工，半双工，全双工，编码，解码，拆包，粘包，netty网络框架通信，nio,线程池，boss线程，work线程，集群负载均衡loadbalace,cluster,router,zk 下载dubbo最新源码(tag:2.8.4) dubbo项目托管在github 上面 123git clone https://github.com/dangdangdotcom/dubboxgit checkout -b dubbo-2.8.4 dubbo-2.8.4 构建环境 maven3.5.0 java8 idea 直接导入idea中 命令行构建 12cd dubbomvn clean package -DskipTests dubbo源码包介绍 dubbo-admin dubbo控制台管理项目 dubbo-cluster dubbo集群实现 dubbo-common dubbo公共类或者工具 dubbo-config dubbo配置实现 dubbo-container dubbo容器:spring容器,jetty,日记实现 dubbo-demo 官网提供的demo dubbo-filter dubbo缓存和验证 dubbo-registry dubbo核心注册中心实现,zk,redis,广播，直连 dubbo-monitor 监控模块，统计服务调用次数和时间，调用链跟踪服务 dubbo-remoting dubbo远程通讯实现 dubbo-rpc 远程调用模块 dubbo-test dubbo一些测试","categories":[{"name":"java","slug":"java","permalink":"http://hadesvip.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://hadesvip.github.io/tags/java/"},{"name":"dubbo源码","slug":"dubbo源码","permalink":"http://hadesvip.github.io/tags/dubbo源码/"}]},{"title":"dubbo教程(一):dubbo入门Demo","slug":"dubbo教程-一-dubbo入门Demo","date":"2018-01-19T06:30:26.000Z","updated":"2018-01-23T11:54:16.711Z","comments":true,"path":"2018/01/19/dubbo教程-一-dubbo入门Demo/","link":"","permalink":"http://hadesvip.github.io/2018/01/19/dubbo教程-一-dubbo入门Demo/","excerpt":"","text":"什么是dubbo? 官网: dubbo.io 官方文档－用户手册: http://dubbo.io/books/dubbo-user-book/ 高性能和透明化的RPC远程服务调用方案 SOA 服务治理方案 dubbo能做什么? 远程化的远程方法调用d 就像调用本地方法一样调用远程方法（动态代理） 只需要简单的配置，没有任何API侵入 软负载均衡及容错机制 可在内网代替F5等硬件负载均衡器 服务自动注册与发现 不需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或者删除服务提供者 dubbo原理 示例 项目demo已经存放在github上面 1git clone https://github.com/hadesvip/dubbo-demo.git 依赖 gradle java8 项目描述 dubbo-demo 父模块，主要维护了子模块的构建信息，构件信息 dubbo-demo-domain dubbo-demo的子模块，里面定义了数据类和接口 dubbo-demo-provider dubbo-demo的子模块，dubbo的服务提供者 dubbo-demo-consumer dubbo-demo的子模块,dubbo服务消费者 项目运行 预先安装zookeeper,并启动zk,启动一个zk就行了，生产环境上最好搭建一个zk集群（3的倍数） 构建 12cd dubbo-demogradle clean build 运行dubbo-demo-provider项目com.provider.Console方法 从控制台上面打印的日记可以看出连接到了zk上面，并把dubbo服务注册到了zk上 123456789101112131415//连接本地zk org.apache.zookeeper.ClientCnxn - Socket connection established to localh ost/127.0.0.1:2181, initiating session//ｚｋ状态为连接状态 org.apache.zookeeper.ClientCnxn - Session establishment complete on server localhost/127.0.0.1:2181, sessionid = 0x100003c49000000, negotiated timeout = 30000 org.I0Itec.zkclient.ZkClient - zookeeper state changed (SyncConnected) //在zk上面注册服务 [DUBBO] Register: dubbo://172.17.0.1:20880/com.service.UserService?anyhost=true&amp;application=dubbo-demo-provider-app&amp;dubbo=2.6.0&amp;generic=false&amp;interface=com.service.UserService&amp;logger=log4j&amp;methods=getUserById&amp;pid=14225&amp;side=provider&amp;timestamp=1516428681983, dubbo version: 2.6.0, current host: 172.17.0.1 //订阅configurators配置 [DUBBO] Subscribe: provider://172.17.0.1:20880/com.service.UserService?anyhost=true&amp;application=dubbo-demo-provider-app&amp;category=configurators&amp;check=false&amp;dubbo=2.6.0&amp;generic=false&amp;interface=com.service.UserService&amp;logger=log4j&amp;methods=getUserById&amp;pid=14225&amp;side=provider&amp;timestamp=1516428681983, dubbo version: 2.6.0, current host: 172.17.0.1//通知订阅这些服务的提供者 [DUBBO] Notify urls for subscribe url provider://172.17.0.1:20880/com.service.UserService?anyhost=true&amp;application=dubbo-demo-provider-app&amp;category=configurators&amp;check=false&amp;dubbo=2.6.0&amp;generic=false&amp;interface=com.service.UserService&amp;logger=log4j&amp;methods=getUserById&amp;pid=14225&amp;side=provider&amp;timestamp=1516428681983, urls: [empty://172.17.0.1:20880/com.service.UserService?anyhost=true&amp;application=dubbo-demo-provider-app&amp;category=configurators&amp;check=false&amp;dubbo=2.6.0&amp;generic=false&amp;interface=com.service.UserService&amp;logger=log4j&amp;methods=getUserById&amp;pid=14225&amp;side=provider&amp;timestamp=1516428681983], dubbo version: 2.6.0, current host: 172.17.0.1 运行dubbo-demo-consumer项目 com.consumer.Console 控制台输出下面语句，说明服务调用成功 1User&#123;userId=&apos;001&apos;, userName=&apos;admin&apos;, email=&apos;admin@126.com&apos;&#125; 从控制台日记也可以知道一些细节 12345678910111213141516171819//连接zkINFO org.apache.zookeeper.ClientCnxn - Socket connection established to localhost/127.0.0.1:2181, initiating session//ZK状态改变为连接状态INFO org.I0Itec.zkclient.ZkClient - zookeeper state changed (SyncConnected)//注册消费者[DUBBO] Register: consumer://172.17.0.1/com.service.UserService?application=dubbo-demo-consumer-app&amp;category=consumers&amp;check=false&amp;dubbo=2.6.0&amp;interface=com.service.UserService&amp;logger=log4j&amp;methods=getUserById&amp;pid=15803&amp;side=consumer&amp;timestamp=1516429428346, dubbo version: 2.6.0, current host: 172.17.0.1//订阅providers,configurators,routers[DUBBO] Subscribe: consumer://172.17.0.1/com.service.UserService?application=dubbo-demo-consumer-app&amp;category=providers,configurators,routers&amp;dubbo=2.6.0&amp;interface=com.service.UserService&amp;logger=log4j&amp;methods=getUserById&amp;pid=15803&amp;side=consumer&amp;timestamp=1516429428346, dubbo version: 2.6.0, current host: 172.17.0.1// 通知订阅了这个地址的服务消费者[DUBBO] Notify urls for subscribe url consumer://172.17.0.1/com.service.UserService?application=dubbo-demo-consumer-app&amp;category=providers,configurators,routers&amp;dubbo=2.6.0&amp;interface=com.service.UserService&amp;logger=log4j&amp;methods=getUserById&amp;pid=15803&amp;side=consumer&amp;timestamp=1516429428346, urls: [dubbo://172.17.0.1:20880/com.service.UserService?anyhost=true&amp;application=dubbo-demo-provider-app&amp;dubbo=2.6.0&amp;generic=false&amp;interface=com.service.UserService&amp;logger=log4j&amp;methods=getUserById&amp;pid=14225&amp;side=provider&amp;timestamp=1516428681983, empty://172.17.0.1/com.service.UserService?application=dubbo-demo-consumer-app&amp;category=configurators&amp;dubbo=2.6.0&amp;interface=com.service.UserService&amp;logger=log4j&amp;methods=getUserById&amp;pid=15803&amp;side=consumer&amp;timestamp=1516429428346, empty://172.17.0.1/com.service.UserService?application=dubbo-demo-consumer-app&amp;category=routers&amp;dubbo=2.6.0&amp;interface=com.service.UserService&amp;logger=log4j&amp;methods=getUserById&amp;pid=15803&amp;side=consumer&amp;timestamp=1516429428346], dubbo version: 2.6.0, current host: 172.17.0.1//成功连接到这个服务地址Successed connect to server /172.17.0.1:20880 from NettyClient 172.17.0.1 using dubbo version 2.6.0, channel is NettyChannel [channel=[id: 0x7f2cfe3f, /172.17.0.1:49624 =&gt; /172.17.0.1:20880]], dubbo version: 2.6.0, current host: 172.17.0.1Refer dubbo service com.service.UserService from url zookeeper://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?anyhost=true&amp;application=dubbo-demo-consumer-app&amp;check=false&amp;dubbo=2.6.0&amp;generic=false&amp;interface=com.service.UserService&amp;logger=log4j&amp;methods=getUserById&amp;pid=15803&amp;register.ip=172.17.0.1&amp;remote.timestamp=1516428681983&amp;side=consumer&amp;timestamp=1516429428346, dubbo version: 2.6.0, current host: 172.17.0.1 在dubbo-demo-provider 控制台也会有下面日记输出 1234567891011//消费者请求4:22:45.913 [New I/O server worker #1-1] WARN c.a.d.r.transport.AbstractServer - [DUBBO] All clients has discontected from /172.17.0.1:20880. You can graceful shutdown now., dubbo version: 2.6.0, current host: 172.17.0.114:22:45.913 [DubboServerHandler-172.17.0.1:20880-thread-3] INFO c.a.d.r.protocol.dubbo.DubboProtocol - [DUBBO] disconected from /192.168.31.44:49580,url:dubbo://172.17.0.1:20880/com.service.UserService?anyhost=true&amp;application=dubbo-demo-provider-app&amp;bind.ip=172.17.0.1&amp;bind.port=20880&amp;channel.readonly.sent=true&amp;codec=dubbo&amp;dubbo=2.6.0&amp;generic=false&amp;heartbeat=60000&amp;interface=com.service.UserService&amp;logger=log4j&amp;methods=getUserById&amp;pid=14225&amp;side=provider&amp;timestamp=1516428681983, dubbo version: 2.6.0, current host: 172.17.0.114:23:49.175 [New I/O server worker #1-2] WARN c.a.d.r.transport.AbstractServer - [DUBBO] All clients has discontected from /172.17.0.1:20880. You can graceful shutdown now., dubbo version: 2.6.0, current host: 172.17.0.114:23:49.175 [DubboServerHandler-172.17.0.1:20880-thread-6] INFO c.a.d.r.protocol.dubbo.DubboProtocol - [DUBBO] disconected from/192.168.31.44:49624,url:dubbo://172.17.0.1:20880/com.service.UserService?anyhost=true&amp;application=dubbo-demo-provider-app&amp;bind.ip=172.17.0.1&amp;bind.port=20880&amp;channel.readonly.sent=true&amp;codec=dubbo&amp;dubbo=2.6.0&amp;generic=false&amp;heartbeat=60000&amp;interface=com.service.UserService&amp;logger=log4j&amp;methods=getUserById&amp;pid=14225&amp;side=provider&amp;timestamp=1516428681983, dubbo version: 2.6.0, current host: 172.17.0.1 更多资料 https://dubbo.io","categories":[{"name":"java","slug":"java","permalink":"http://hadesvip.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://hadesvip.github.io/tags/java/"},{"name":"dubbo","slug":"dubbo","permalink":"http://hadesvip.github.io/tags/dubbo/"},{"name":"rpc","slug":"rpc","permalink":"http://hadesvip.github.io/tags/rpc/"},{"name":"soa","slug":"soa","permalink":"http://hadesvip.github.io/tags/soa/"}]},{"title":"codeStyle模板和p3c代码规则检测插件配置","slug":"codeStyle模板和p3c代码规则检测插件配置","date":"2018-01-19T03:25:39.000Z","updated":"2018-01-23T11:54:16.711Z","comments":true,"path":"2018/01/19/codeStyle模板和p3c代码规则检测插件配置/","link":"","permalink":"http://hadesvip.github.io/2018/01/19/codeStyle模板和p3c代码规则检测插件配置/","excerpt":"","text":"格式化模板 使用的是谷歌的codeStyle 地址 1git clone https://github.com/google/styleguide.git 配置(下面是关于idea中的配置,eclipse同理) eclipse 选择的是eclipse-java-google-style.xml ,idea 选择的是 intellij-java-google-style.xml p3c代码规则检测插件 阿里的代码规则检测插件 地址 1git clone https://github.com/alibaba/p3c.git 安装 idea eclipse 参照官方描述 https://github.com/alibaba/p3c/tree/master/eclipse-plugin 使用 参照 https://github.com/alibaba/p3c/wiki","categories":[{"name":"java","slug":"java","permalink":"http://hadesvip.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://hadesvip.github.io/tags/java/"},{"name":"工作笔记","slug":"工作笔记","permalink":"http://hadesvip.github.io/tags/工作笔记/"},{"name":"工具","slug":"工具","permalink":"http://hadesvip.github.io/tags/工具/"}]}]}